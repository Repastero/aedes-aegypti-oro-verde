/**
 * 
f * This file was automatically generated by the Repast Simphony Agent Editor.
 * Please see http://repast.sourceforge.net/ for details.
 * 
 */

/**
 *
 * Set the package name.
 *
 */
package infeccion


/**
 *
 * Import the needed packages.
 *
 */
import java.math.*
import javax.measure.unit.*
import org.jscience.mathematics.number.*
import org.jscience.mathematics.vector.*

import repast.simphony.adaptation.neural.*
import repast.simphony.adaptation.regression.*
import repast.simphony.context.*
import repast.simphony.context.space.continuous.*
import repast.simphony.context.space.gis.*
import repast.simphony.context.space.graph.*
import repast.simphony.context.space.grid.*
import repast.simphony.engine.environment.*
import repast.simphony.engine.schedule.*
import repast.simphony.engine.watcher.*
import repast.simphony.groovy.math.*
import repast.simphony.integration.*
import repast.simphony.matlab.link.*
import repast.simphony.query.*
import repast.simphony.query.space.continuous.*
import repast.simphony.query.space.gis.*
import repast.simphony.query.space.graph.*
import repast.simphony.query.space.grid.*
import repast.simphony.query.space.projection.*
import repast.simphony.parameter.*
import repast.simphony.random.*
import repast.simphony.space.SpatialException
import repast.simphony.space.continuous.*
import repast.simphony.space.gis.*
import repast.simphony.space.graph.*
import repast.simphony.space.grid.*
import repast.simphony.space.projection.*
import repast.simphony.ui.probe.*
import repast.simphony.util.*
import simphony.util.messages.*
import static java.lang.Math.*
import static repast.simphony.essentials.RepastEssentials.*

/**
 *
 * This is an agent.
 *
 */
public class humanos  {

    /**
     *
     * This is an agent property.
     * @field IPeriod
     *
     */
    @Parameter (displayName = "Periodo Intrinseco", usageName = "IPeriod")
    public int getIPeriod() {
        return IPeriod
    }
    public void setIPeriod(int newValue) {
        IPeriod = newValue
    }
    public int IPeriod = 0

    /**
     *
     * This is an agent property.
     * @field infected
     *
     */
    @Parameter (displayName = "Infectado", usageName = "infected")
    public boolean getInfected() {
        return infected
    }
    public void setInfected(boolean newValue) {
        infected = newValue
    }
    public boolean infected = false

    /**
     *
     * This is an agent property.
     * @field posfutura
     *
     */
    @Parameter (displayName = "Posicion futura", usageName = "posfutura")
    public GridPoint getPosfutura() {
        return posfutura
    }
    public void setPosfutura(GridPoint newValue) {
        posfutura = newValue
    }
    public GridPoint posfutura

    /**
     *
     * This is an agent property.
     * @field cargaviralhumano
     *
     */
    @Parameter (displayName = "carga viral humano", usageName = "cargaviralhumano")
    public boolean getCargaviralhumano() {
        return cargaviralhumano
    }
    public void setCargaviralhumano(boolean newValue) {
        cargaviralhumano = newValue
    }
    public boolean cargaviralhumano = false

    /**
     *
     * This is an agent property.
     * @field index
     *
     */
    @Parameter (displayName = "indice de direccion", usageName = "index")
    public def getIndex() {
        return index
    }
    public void setIndex(def newValue) {
        index = newValue
    }
    public def index = 0

    /**
     *
     * This is an agent property.
     * @field viremia
     *
     */
    @Parameter (displayName = "viremia", usageName = "viremia")
    public int getViremia() {
        return viremia
    }
    public void setViremia(int newValue) {
        viremia = newValue
    }
    public int viremia = 0

    /**
     *
     * This is an agent property.
     * @field recuperado
     *
     */
    @Parameter (displayName = "Recuperado", usageName = "recuperado")
    public boolean getRecuperado() {
        return recuperado
    }
    public void setRecuperado(boolean newValue) {
        recuperado = newValue
    }
    public boolean recuperado = false

    /**
     *
     * This is an agent property.
     * @field sospechoso
     *
     */
    @Parameter (displayName = "sospechoso", usageName = "sospechoso")
    public boolean getSospechoso() {
        return sospechoso
    }
    public void setSospechoso(boolean newValue) {
        sospechoso = newValue
    }
    public boolean sospechoso = false

    /**
     *
     * This is an agent property.
     * @field caso_reportado
     *
     */
    @Parameter (displayName = "casoReportado", usageName = "caso_reportado")
    public int getCaso_reportado() {
        return caso_reportado
    }
    public void setCaso_reportado(int newValue) {
        caso_reportado = newValue
    }
    public int caso_reportado = 0

    /**
     *
     * This is an agent property.
     * @field tiempoentradacaso
     *
     */
    @Parameter (displayName = "entrada caso sospechoso", usageName = "tiempoentradacaso")
    public def getTiempoentradacaso() {
        return tiempoentradacaso
    }
    public void setTiempoentradacaso(def newValue) {
        tiempoentradacaso = newValue
    }
    public def tiempoentradacaso = 0

	/**
	 * 
	 * MaxiF: Lista de agentes con los que tuvo contacto.
	 * 			La idea de esto es para medir la red de contactos, no afecta el comportamiento.
	 * 			Se agrega al arreglo por cada 1/32 tick todos los que tenga alrededor que no estén ya en el arreglo.
	 * 
	 */
	
	private def contactados = []
	public def getContactados() {
		return contactados
	}
	public void setContactados(def newValue) {
		contactados = newValue
	}
	
	
	/**
	 *
	 * Maxi F: Devuelve la posición X y Y del agente
	 *
	 */
	public def getPosX() {
		Grid grid=FindGrid("infeccion/grid")
		GridPoint pt=grid.getLocation(this)
		return pt.getX()
	}

	public def getPosY() {
		Grid grid=FindGrid("infeccion/grid")
		GridPoint pt=grid.getLocation(this)
		return pt.getY()
	}
	
	
	//================== Propiedades para el desplazamiento =====================
	
	//Id de trabajo, solo para graficar
	private int IDTrabajo
	public int getIDTrabajo() {
		return IDTrabajo
	}
	public void setIDTrabajo(int newValue) {
		IDTrabajo = newValue
	}

			
	//Posición del trabajo
	private GridPoint posTrabajo = new GridPoint(0,0) 
	public GridPoint getPosTrabajo() {
		return posTrabajo
	}
	public void setPosTrabajo(GridPoint newValue) {
		posTrabajo = newValue
	}
	
	//Posición de la casa 
	private GridPoint posCasa = new GridPoint(0,0)
	public GridPoint getPosCasa() {
		return posCasa
	}
	public void setPosCasa(GridPoint newValue) {
		posCasa = newValue
	}

	//Localización actual es el estado de markov donde está. El nodo 0 es la casa, el 1 es el trabajo/estudio, el 2 es ocio, el 3 es otros (supermercados, farmacias, etc)
 	private int localizActual = 0
	public int getLocalizActual() {
		return localizActual
	}
	public void setLocalizActual(int newValue) {
		localizActual = newValue
	}
	
	//Posición localización actual es la coordenada donde está la localización actual.
	private GridPoint posLocalizActual
	public GridPoint getPosLocalizActual() {
		return posLocalizActual
	}
	public void setPosLocalizActual(GridPoint newValue) {
	   posLocalizActual = newValue
	}

	//La velocidad de traslado es la velocidad a la que se mueve de un nodo a otro.
	private double velTraslado = 0
	public double getVelTraslado() {
		return velTraslado
	}
	public void setVelTraslado(double newValue) {
		velTraslado = newValue
	}
	
	//La matriz TMMC es la matriz que define la probabilidad de traspaso entre los nodos de la máquina de markov.
	private def matrizTMMC = 0
	public def getMatrizTMMC() {
		return matrizTMMC
	}
	public void setMatrizTMMC(def newValue) {
		matrizTMMC = newValue
	}
	
	//================== Definiciones de identificadores propios de repast =====================
	
    /**
     *
     * This value is used to automatically generate agent identifiers.
     * @field serialVersionUID
     *
     */
    private static final long serialVersionUID = 1L

    /**
     *
     * This value is used to automatically generate agent identifiers.
     * @field agentIDCounter
     *
     */
    protected static long agentIDCounter = 1

    /**
     *
     * This value is the agent's identifier.
     * @field agentID
     *
     */
    protected String agentID = "humanos " + (agentIDCounter++)

	
	//================== Inicio de los métodos =====================
	
    /**
     *
     * This is the step behavior.
     * @method calcularMovimiento
     *
     */
    @ScheduledMethod(
        start = 0d,
        interval = 0.03125d,
        priority = 0.6d,
        shuffle = true
    )
    public def calcularMovimiento() {

        // Define the return value variable.
        def returnValue

        // Note the simulation time.
        def time = GetTickCountInTimeUnits()

		// MaxiF: Este método calcula la posición, pero no mueve. Se calcula cada 1/32 ticks, pero desfasado 1/64 ticks.
		
		// MaxiF: Teniendo en cuenta la posición actual, sabiendo donde debería estar (localizActual), la posición de donde 
		//			está el lugar donde debería estar [locTrabajo, locCasa, locOcio, locOtro] y la velocidad de traslado, 
		//			caclula la posFutura.
		 
		// MaxiF: Consigue el grid y la posición actual.
		Grid grid=FindGrid("infeccion/grid")
		GridPoint pt=grid.getLocation(this)

		// MaxiF: La velocidad velTraslado te marca la velocidad en unidades/(1/32)ticks, donde cada unidad son 5 metros,
		//			y un tick es una hora. Ej: La marcha humana es de 6km/Hora, entonces son aprox 38 unidades/tick.
		
		//MaxiF: Usando la propiedad de triangulos equivalentes calculo la posFutura.
		//			xFutura = xActual + distanciaXaObjetivo * sqrt(velocidad/hipotenusaaObjetivo^2)
		//			lo mismo para y.
		
		//MaxiF: si no estoy donde tengo que estar, me muevo
		if (grid.getDistanceSq(pt, this.getPosLocalizActual()) < this.getVelTraslado()){
			//MaxiF: Finalmente seteo PosFutura
			this.setPosfutura(this.getPosLocalizActual())

		}else if (grid.getDistanceSq(pt, this.getPosLocalizActual()) > 0){
			//MaxiF: Calculo la raiz sqrt(velocidad/hipotenusaaObjetivo^2)
			double beta = sqrt(this.getVelTraslado()/grid.getDistanceSq(pt, this.getPosLocalizActual()))
			
			//MaxiF: Calculo x y y.
			int x = pt.toIntArray(null)[0] + (this.getPosLocalizActual().toIntArray(null)[0] - pt.toIntArray(null)[0])*beta
			int y = pt.toIntArray(null)[1] + (this.getPosLocalizActual().toIntArray(null)[1] - pt.toIntArray(null)[1])*beta
	
			//MaxiF: Finalmente seteo PosFutura		
			this.setPosfutura(new GridPoint(x,y))
		}
		
		// Return the results.
		return returnValue
    }

    /**
     *
     * This is the step behavior.
     * @method updateinfection
     *
     */
    @ScheduledMethod(
        start = 0d,
        pick = 9223372036854775807l,
        interval = 0.03125d,
        priority = 0.7d,
        shuffle = true
    )
    public def updateinfection() {

        // Define the return value variable.
        def returnValue

        // Note the simulation time.
        def time = GetTickCountInTimeUnits()


        // MaxiF: Este método calcula los cambios de estado de los humanos.
		// MaxiF: Primero revisa que no sea recuperado, si es recuperado, no hay que 
		//		hacer nada porque ya está en R
        if (!recuperado) {
			// MaxiF: Revisa ahora que tenga carga viral. Si no tiene carga viral, y como vimos,
			//		no es R, significa que es S. Si tiene carga viral, puede ser E o I.
            if (cargaviralhumano ) {
				// MaxiF: Revisa que esté infeccioso. Si está infeccioso (infected), está en estado I.
				//		Si no está infeccioso, está en estado E.
                if (infected) {
					// MaxiF: Si está en estado I, empieza a correr el contador viremia, que dice
					//		cuando pasa de I a R
					if (this.viremia>0) {
                        // Decrementa el contador viremia
                        viremia--
                    } else  {
						// MaxiF: Si se agotó el tiempo de viremia pasa a estado R.
                        setCargaviralhumano(false)
                        setInfected(false)
                        setRecuperado(true)
                    }
                } else  {
                    // MaxiF: En este caso, está en estado E, y pasando el tiempo IPeriod, va a pasar
					//		al estado I.
                    if (IPeriod<1) {
                        // MaxiF: Pasado el tiempo IPeriod, paso al estado I  
                        setInfected(true)
						// MaxiF: Esta función Caso Reportado, actualmente no la uso, ya que implica 
						//		programar un dataset muy complicado. En cambio calculo los casos reportados
						//		diarios en base a álgebra considerando los casos R e I. Ver método Step1.
                        setCaso_reportado(1)
                    } else  {
                        // MaxiF: Decremento el contador IPeriod.
                        IPeriod--
                    }
                }
            }
        }
		
        // Return the results.
        return returnValue

    }


    /**
     *
     * This is the step behavior.
     * @method mover
     *
     */
    @ScheduledMethod(
        start = 0.015625d,
        interval = 0.03125d,
        priority = 0.7d,
        shuffle = true
    )
    public def mover() {

        // Define the return value variable.
        def returnValue

        // Note the simulation time.
        def time = GetTickCountInTimeUnits()

        // MaxiF: Este método aplica el movimiento calculado en "moved"
		// MaxiF: Repast tira un error cuando se sobrepasa el borde. En strict, tira el error y nada más.
		//		en sticky, tira el error, y maneja el error haciendo que el agente se quede pegado al borde. 
        
		try {
			//Intenta mover.
			Grid grid=FindGrid("infeccion/grid")
	        grid.moveTo(this, posfutura.toIntArray(null))
		} catch (SpatialException ex) {
			//Si hay un error de este tipo, es porque está tratando de moverse fuera del grid
			//Se cambia entonces al opuesto el sentido de movimiento, 'rebota'.
			//Para esto, si el index vale 1 pasa a 3, si vale 2 pasa a 4 y viceversa.
			this.setIndex(this.getIndex() + 2)
			if (this.getIndex() > 4){
				this.setIndex(this.getIndex() - 4)
			}
		}
		
		
        // Return the results.
        return returnValue

    }

	
	/**
	 *
	 * This is the step behavior.
	 * @method mover
	 *
	 */
	@ScheduledMethod(
		//start = 5000d,  //Descomentar esto si no se quiere calcular la red de contactos y ganar mucho en performance.
		//start = 0d,  //Descomentar esto si se quiere calcular la red de contactos.
		interval = 1d,
		priority = 0.99d,
		shuffle = true
	)
	public def calcularRed() {

		// Define the return value variable.
		def returnValue

		// Note the simulation time.
		def time = GetTickCountInTimeUnits()

		// MaxiF: En este comportamiento se actualiza la red de contactos. Se agregan
		//			todos los vecinos nuevos que encuentre.
		
		//MaxiF: Para obtener los contactos, primero arranqué con una proyección tipo network, pero
		//		es tan grande la red que terminó siendo re ineficiente.
		//		Entonces lo solucioné con que cada agente tenga una lista de a quienes contactó
		
		Grid grid=FindGrid("infeccion/grid")
		GridPoint pt = grid.getLocation(this)

		//Network red = FindNetwork("infeccion/redContactos")
		
		def vecinos = new MooreQuery(grid, this, 1, 1)
		
		for (v in vecinos.query()) {
				/* Esto no se usa porque ya no utilizo la proyeccion de red, sino el arreglo.
				//MaxiF: Intenta crear el nodo, si no puede es porque ya está creado.
				if(red.getEdge(this,v) == null){
					red.addEdge(this,v)
				}*/
				if(!(this.contactados.contains(v.toString())) && v.getClass() == this.getClass()){
					this.contactados.add(v.toString())
				}
		}
		
		// Return the results.
		return returnValue

	}
	
	public String obtenerContactos(){
		
		//MaxiF: Para obtener los contactos, primero arranqué con una proyección tipo network, pero
		//		es tan grande la red que terminó siendo re ineficiente.
		//		Entonces lo solucioné con que cada agente tenga una lista de a quienes contactó
		
		//Este método, devuelve un string con un formato similar al que usa networkx. La idea es 
		//		llamarlo al final y grabar la respuesta en un archivo de texto con un data sink.
		
		//Network red = FindNetwork("infeccion/redContactos")
		
		String salida = ''
		
		//def contactados = red.getAdjacent(this)
		for (c in this.contactados){
			salida += "${this} ${c};"
		}
		
		return salida
	}
	
    /**
     *
     * This is the step behavior.
     * @method step
     *
     */
    @ScheduledMethod(
        start = 0d,
        interval = 1d,
        priority = 0.9d,
        shuffle = true
    )
    public def step() {

        // Define the return value variable.
        def returnValue

        // Note the simulation time.
        def time = GetTickCountInTimeUnits()

        // MaxiF: Este método hace ingresar a los casos iniciales. 
        ISchedule schedule = RunEnvironment.getInstance().getCurrentSchedule()
        double currentTime= schedule.getTickCount()

        // MaxiF: Los casos iniciales son los que tienen sospechoso == true, e ingresan en tiempoentradacaso
        if (sospechoso&&currentTime==tiempoentradacaso) {
			//MaxiF: Ingresan como I, no pasan por E. 
            setInfected(true)
            setCargaviralhumano(true)
        }
		
		// Return the results.
        return returnValue

    }

    /**
     *
     * This is the step behavior.
     * @method step1
     *
     */
    @ScheduledMethod(
        start = 12d,
		//start = 12000.01d,
        pick = 9223372036854775807l,
        interval = 12d,
        priority = 0.1d,
        shuffle = true
    )
    public def step1() {

        // Define the return value variable.
        def returnValue

        // Note the simulation time.
        def time = GetTickCountInTimeUnits()


        // MaxiF: Este método devuelve si este humano se considera como caso reportado.
		//		El tema es que como se resetea automático cada 12 ticks, tenes que agarrarlo justo.
		//		Si se implementara como un getter podría ser más fácil.
		//		De todas maneras ahora no se usa, porque se mide con álgebra desde la cantidad de I,
		//		y la cantidad de R:
		//		Para caclular los nuevos infectados NI en el día actual, dado los infectados I, los infectados en el día anterior IA, los
		//		recuperados R, y los recuperados en el tick anterior RA, se hace:
		//				NI = I - IA + R - RA
		//MaxiF: Una propuesta de cambiar esto, es sacar esta función, y hacer que se resetee el valor en getCaso_reportado. 
		//MaxiF: En resumen, esto no se usa ahora, y si se usara, hay otras formas de hacerlo.
		//
        if (caso_reportado) {

            // This is a task.
            setCaso_reportado(0)

        } else  {


        }
        // Return the results.
        return returnValue

    }

	
    /**
     *
     * This method provides a human-readable name for the agent.
     * @method toString
     *
     */
    @ProbeID()
    public String toString() {

        // Define the return value variable.
        def returnValue

        // Note the simulation time.
        def time = GetTickCountInTimeUnits()

        // Set the default agent identifier.
		// MaxiF: Hice un pequeño cambio para que devuelva el ID solamente, y ahorrar muchos
		//		bytes en el reporte de las posiciones.
        returnValue = this.agentID.substring(8)
		
        // Return the results.
        return returnValue

    }
	
	/**
	 *
	 * Este es el comportamiento de cambiar lugar donde va a estar
	 * según TMMC (Timed mobility markov chains)
	 * @method CambiarPosicionMarkov
	 *
	 */
	@ScheduledMethod(
		start = 0d,
		interval = 1.0d,
		priority = 0.6d,
		shuffle = true
	)
	public def CambiarPosicionMarkov() {

		// Define the return value variable.
		def returnValue

		// Note the simulation time.
		def time = GetTickCount()

		
		// MaxiF: Este método cambia el lugar donde va a estar el humano en cada hora.
		//			Esto se hace con cadenas de mobilidad de markov temporales.
		
		// MaxiF: Para elegir si cambiar o no uso u algoritmo de selección ponderado.
		// MaxiF: La matriz tiene la forma 	probabilidadTMMC[P,i,j], donde P es el período del día (mañana, siesta, tarde, anochecer)
		//		i es el nodo de donde sale, y j es el nodo a donde va.
		// MaxiF: Averiguo el período en el que estoy
		int p =  ((int)time%12)/3
		
		// MaxiF: Ahora selecciono el siguiente lugar
		double r = RandomHelper.nextDoubleFromTo(0,1)
		int i;
		for (i = 0; r > (double)(this.getMatrizTMMC()[p][this.getLocalizActual()][i]); i++){
			r -= this.getMatrizTMMC()[p][this.getLocalizActual()][i]
		}
		
		// MaxiF: Ahora cambio la localización actual a la calculada recién si es que cambió
		if(this.getLocalizActual() != i){
			this.setLocalizActual(i)
			this.setPosLocalizActual(this.posLocaliz(i))
		}
		
		// Return the results.
		return returnValue
	}
	
	
	private GridPoint posLocaliz(int i){
		// MaxiF: Consigo la ciudad para usar los datos de las locaciones.
		Context context = new ContextUtils().getContext(this)
		def ciudad = new PropertyEquals(context, "EsAmbiente", true).query()[0]
		
		switch(i){
			case 0:
				return this.getPosCasa()
			case 1:
				return this.getPosTrabajo()
			case 2:
				return ciudad.posOcio()
			case 3:
				return ciudad.posOtros()
		}
	}

}

